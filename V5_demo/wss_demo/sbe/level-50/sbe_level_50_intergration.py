# sbe_ob50_client.py
import asyncio
import websockets
from typing import Tuple, List

from bybit_sbe import MessageHeader, OBL50Event  # generated by SBE tool
from orderbook import OrderBook

WS_URL = "wss://stream.bybit.com/v5/market/sbe"  # example
CHANNEL = "ob.50.sbe.BTCUSDT"  # example symbol


def decode_obl50(buf: bytes) -> OBL50Event:
    """
    Decode a single OBL50Event from binary buffer:
    [messageHeader][OBL50Event]
    """
    header = MessageHeader()
    header.wrap(buf, 0, 0, len(buf))

    if header.templateId() != 20001:
        raise ValueError(f"Unexpected templateId: {header.templateId()}")

    msg = OBL50Event()
    # message starts right after header.encodedLength()
    msg.wrapForDecode(buf, header.encodedLength(), header.blockLength(), header.version())
    return msg


def to_real(value: int, exponent: int) -> float:
    # mantissa * 10^exponent
    return value * (10 ** exponent)


def extract_levels(msg: OBL50Event) -> Tuple[List[Tuple[float, float]], List[Tuple[float, float]]]:
    px_exp = msg.priceExponent()
    sz_exp = msg.sizeExponent()

    asks = []
    bids = []

    for ask in msg.asks():
        p = to_real(ask.price(), px_exp)
        s = to_real(ask.size(), sz_exp)
        asks.append((p, s))

    for bid in msg.bids():
        p = to_real(bid.price(), px_exp)
        s = to_real(bid.size(), sz_exp)
        bids.append((p, s))

    return asks, bids


async def handle_ob50_stream():
    book = OrderBook()

    async with websockets.connect(WS_URL) as ws:
        # Subscribe – assuming JSON subscription wrapper for SBE binary
        sub_msg = {
            "op": "subscribe",
            "args": [CHANNEL],
        }
        import json
        await ws.send(json.dumps(sub_msg))

        while True:
            raw = await ws.recv()

            # Some WS setups send binary frames for SBE
            if isinstance(raw, str):
                # ignore non-SBE control frames, pongs etc
                continue

            msg = decode_obl50(raw)
            u = msg.u()
            pkg_type = msg.pkgType()  # 0 = SNAPSHOT, 1 = DELTA
            asks, bids = extract_levels(msg)

            # continuity rule:
            # if u == 1 => reset sequence
            if u == 1:
                # special snapshot (service restart / precision change)
                book.bids.snapshot_from(bids)
                book.asks.snapshot_from(asks)
                book.last_u = 1
                print(f"[RESET SNAPSHOT] u={u}, seq={msg.seq()}, symbol={msg.symbol()}")
                continue

            # for u != 1 => optional continuity check
            if book.last_u != 0 and u != book.last_u + 1:
                print(
                    f"[WARN] u jump detected lastU={book.last_u}, newU={u} – resync recommended"
                )
                # you might resubscribe or request a recovery snapshot here

            if pkg_type == 0:  # SNAPSHOT
                book.bids.snapshot_from(bids)
                book.asks.snapshot_from(asks)
            else:  # DELTA
                for p, s in asks:
                    book.asks.apply_level(p, s)
                for p, s in bids:
                    book.bids.apply_level(p, s)

            book.last_u = u

            # Example: print top of book
            best_bid = max(book.bids.levels.keys()) if book.bids.levels else None
            best_ask = min(book.asks.levels.keys()) if book.asks.levels else None
            print(f"u={u} pkgType={pkg_type} bestBid={best_bid} bestAsk={best_ask}")


if __name__ == "__main__":
    asyncio.run(handle_ob50_stream())